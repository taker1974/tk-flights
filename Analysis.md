# Тестовое задание для старта трудоустройства № 2: анализ

## Дано

Определения в виде готовых классов для основных элементов системы:  

- класс Segment - отрезок всего полёта;
- класс Flight - полный перелёт в виде набора отрезков полёта;
- класс FlightBuilder - вспомогательный класс для построения [тестовых] данных по Segment и Flight.

Надо создать модуль Java (класс, набор классов, интерфейсы etc.).  

Задача модуля - фильтрация набора перелётов.  
Указано, что:  

- правил фильтрации может быть очень много;
- наборы перелётов также могут быть очень большими;
- правила могут выбираться и задаваться динамически.

На что это может влиять?

**Много правил фильтрации**: полиморфизм в том или ином виде; нужен абстрактный интерфейс для функции фильтрации.

**Большие наборы перелётов**: для работы фильтра по потоку не имеет значения; подтверждение тому, что фильтрация будет выполняться на потоках с возможным применением параллелизма.

**Динамический выбор правил**: подтверждение того, что каждая функция фильтрации - это экземпляр единого интерфейса или соответствующая интерфейсу лямбда.

Готовые библиотеки с нужным функционалом использовать нельзя.
Достаточно вывода информации в консоль.  
Покрыть код тестами.  

Весь код необходимо поместить в пакет **com.gridnine.testing**.

## Что запускается при проверке, как выполняется проверка

Для проверочного запуска создайте публичный класс Main c методом main().  
Этот метод должен выдать в консоль результаты обработки тестового набора перелётов:  

```Java
package com.gridnine.testing;
//...
public class Main {

    public static void main(String[] args) {

        List<Flight> flights = FlightBuilder.createFlights();
        
        // Применение методов фильтрации по набору flights
        List<Flight> filteredFlights = flights.stream()
            .noneMatch(<filter_1>)
            .noneMatch(<filter_2>)
            .noneMatch(<filter_N>)
            .collect(<...>);
        
        // Вывод результатов фильтрации
        filteredFlights.stream().forEach(<...>);
    }
}
```

## Конкретные правила фильтрации, которые предписано реализовать

Из ТЗ:  
_Исключите из тестового набора **перелёты** по следующим правилам (по каждому правилу нужен отдельный вывод списка перелётов)_.

Значит есть ```List<Flight> flights```, где Flight - это в основе ```List<Segment>```, и требуется исключить из flights некоторые элементы, создав при этом новый ```List<Flight> filteredFlights```.  

**Вылет до текущего момента времени** (вылет уже должен был произойти ранее):  
берём текущую дату так, как это сделано в классе FlightBuilder:

```Java
LocalDateTime now = LocalDateTime.now();
```

и ищем в наборе все Flight, в которых есть сегменты с датой вылета раньше, чем now.

**Сегменты с датой прилёта раньше даты вылета**:  просто ищем невалидные Segment, сравнивая даты прилёта и вылета.

**Перелёты, где общее время, проведённое на земле, превышает N единиц времени (время на земле — это интервал между прилётом одного сегмента и вылетом следующего за ним).**  

Слова _"Исключите из тестового набора перелёты ..."_ говорят о том, что фильтрация по потоку выполняется методом noneMatch().

Слова _"... по каждому правилу нужен отдельный вывод списка перелётов"_ говорят о том, что неплохо было бы в метод фильтрации передавать коллбэк с дополнительными обработками объекта перелётов (вывод в консоль, например).
